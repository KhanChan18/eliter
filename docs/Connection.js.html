<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Connection.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Connection.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict"

var zlib = require('zlib'),
    url = require('url'),
    query = require('querystring'),
    file = require('./file'),
    getSession = require('./Session'),
    logger = require('./logger')

const HEADERS = {
        'server': 'black-tech',
        'Connection': 'keep-alive',
        'charset': 'utf-8',
        'Content-Type': 'text/plain'
    },
    CONTENT_TYPE = {
        'html': 'text/html',
        'json': 'application/json',
        'text': 'text/plain'
    }

/** Class describe the connection of each request */
class Connection {
    /**
     * @param  {http.IncomingMessage} req  Node's request object
     * @param  {http.ServerResponse}  res  Node's response object
     * @param  {Object}               conf Config
     * @return {Connection}
     */
    constructor(req, res, conf) {

        /** @type {http.IncomingMessage} Request */
        this._req = req

        /** @type {http.ServerResponse} Response */
        this._res = res

        this._conf = conf
        this.url = url.parse(this._req.url)
        this.query = this.url.query &amp;&amp; query.parse(this.url.query)
    }

    /**
     * Send data as respones
     * 
     * @param  {(String|Object)} sel           Type of data or headers to set.
     * @param  {Number}          [sel.status]  HTTP code
     * @param  {Object}          [sel.headers] Headers of response
     * @param  {(String|Object)} data          Data to send
     * @return {Connection} Return self
     *
     * @public
     */
    send(sel, data) {

        let stat,

            /** Copy defult headers */
            cur_headers = Object.assign({}, HEADERS)
        
        if (typeof sel === 'string') {
            if (!CONTENT_TYPE[sel]) {
                logger.msg(conn, `Unkown sending selection "${sel}", using text/plain`)
            }
            cur_headers['Content-Type'] = CONTENT_TYPE[sel]
            stat = 200


        /** If sel param is Object, copy status code and headers */

        } else {

            // let {status, headers} = sel
            // Nodejs doesn't support destructing....
            // 14th Feb. 2016

            stat = sel.status
            Object.assign(cur_headers, sel.headers)
        }

        // this._res.writeHead(stat, cur_headers)
        if (data) {

            /** If data is an object, send JSON */
            if (typeof data !== 'string') {
                data = JSON.stringify(data)
            }


            if (acceptGzip(this._req)) {

                /** Compose */
                zlib.gzip(data, (err, result) => {
                    if (err) {
                        logger.msg("error gzipping!")
                        this._sendRes(500, cur_headers, "error gzipping!")
                    } else {
                        cur_headers['Content-Encoding'] = 'gzip'
                        this._sendRes(stat, cur_headers, result)
                    }
                })
            } else {
                this._sendRes(stat, cur_headers, data)
            }
        } else {
            this._sendRes(stat, cur_headers)
        }

        /** Developing log */
        if (process.env.NODE_ENV === 'development') {
            logger.msg(this, data)
        }
        return this
    }

    _sendRes(code, headers, data) {
        this._res.writeHead(code, headers)
        this._res.end(data)
    }
    /** Assign to `redirect` */
    jump(loc) {
        return this.redirect(loc)
    }

    /**
     * Send response to redirect
     * @param  {String} loc Location to redirect
     * @return {Connection} Return self
     *
     * @public
     */
    redirect(loc) {
        return this.send({
            status: 302,
            headers: {
                Location: loc
            }
        })
    }

    /**
     * Send a res as error
     * @param  {String} str      String descripting error
     * @param  {Number} [code=500] Http code of the error
     * @return {Connection} Return self
     *
     * @public
     */
    error(str, code/* = 500*/) {
        code = code || 500
        return this.send({
            status: code
        }, str)
    }

    /**
     * Set cookies
     * @param {Object} cookie_data data of cookies
     * @return {Connection} Return self
     *
     * @public
     */
    setCookie(cookie_data) {
        var cookies, k, v
        cookies = (function() {
            var results
            results = []
            for (k in cookie_data) {
                v = cookie_data[k]
                results.push(k + "=" + v)
            }
            return results
        })();
        this._res.setHeader('Set-Cookie', cookies.join(';'))
        return this
    }
    /**
     * Get request body
     * @param  {Number} [max_size = 1e6] The max size of data.
     * Kill connection if overflow.
     * @return {Promise} Promise of http body's data
     *
     * @public
     */
    getBody(max_size/* = 1e6*/) {
        if (!max_size) { max_size = 1e6 }

        let req = this._req
        return new Promise((resolve, reject) => {
            let http_body = ''
            req.on('data', post_chunk => {
                http_body += post_chunk
                if (http_body.length > max_size) {
                    req.connection.destroy()
                    reject()
                }
            })
            req.on('end', () => resolve(http_body))
        })
    }
    /**
     * Get cookie of current request
     * @return {Object} Object include cookies
     *
     * @public
     */
    get cookie() {
        let cookies = {},
            headers = this._req.headers
        if (headers.cookie) {
            for (let cookie of headers.cookie.split(';')) {
                let parts = cookie.split('=')
                cookies[parts[0].trim()] = (parts[1] || '').trim()
            }
        }

        return cookies
    }

    get headers() {
        return this._req.headers
    }
    /**
     * Config getter
     * @return {Object} config
     */
    get config() {
        return this._conf
    }

    get method() {
        return this._req.method.toLowerCase()
    }
}


Connection.prototype.sendFile = file
Connection.prototype.session = getSession


function acceptGzip(request) {
    let acceptEncoding = request.headers['accept-encoding'] || ""
    return /\bgzip\b/.test(acceptEncoding)
}


module.exports = Connection
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Connection.html">Connection</a></li><li><a href="Eliter.html">Eliter</a></li><li><a href="Session.html">Session</a></li></ul><h3>Global</h3><ul><li><a href="global.html#parseRoute">parseRoute</a></li><li><a href="global.html#sendFile">sendFile</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Mon Feb 22 2016 20:37:09 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
